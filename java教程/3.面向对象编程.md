# 面向对象编程

Java是一种面向对象的编程语言。面向对象编程，英文是Object-Oriented Programming,简称OOP.

与面向对象编程不同的，是面向过程编程。面向过程编程，是将模型分解为一步一步的过程。比如一个老板告诉你，要编写一个TODO任务，必须按照以下步骤一步一步来：

1. 读取文件;
2. 编写TODO;
3. 保存文件.

面向对象编程，顾名思义，你得首先有个对象：

    GirlFriend gf = new GirlFriend();
    gf.name = "alice";
    gf.send = ("flowers");

其实就是由现实世界的一种思想方法抽象到计算机模拟的一种编程方法。

所以在本章中，我们将讨论：

面向对象的基本概念：

- 类
- 实例
- 方法

Java语言本身提供的机制，包括：

- package
- classpath
- jar

以及Java标准库提供的核心类，包括：

- 字符串
- 包装类型
- JavaBean
- 枚举
- 常用工具类

希望各位可以通过本章的学习，基本理解并掌握面向对象的基本思想。

## 面向对象基础


面向对象编程，是一种通过对象的方式，将现实世界映射到计算机模型的一种编程方法。

在现实世界中，我们定义了一个“人”的这种抽象概念，而具体的人则是"小明"、"小红"等等，一个个具体的人。所以，在现实世界中，我们可以将"人"定义为一个`类(class)`, 而具体的人则是`实例(instance)`。

**class和instance**

所以，只要理解了**class**和**instance**的概念，基本上就明白了什么是**面向对象编程**。

class是一种对象模板，它定义了如何创建实例，因此，class本身就是一种数据类型。

而instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自的属性可能不相同。

**定义class**

在Java中，创建一个类，例如，将这个类命名为`Persin`，就是定义一个`class`:

    class Person{
        public String name;
        public int age;
    }

一个`class`可以包含多个字段(`field`), 字段用来描述一个类的特征。上面的`Person`类，我们就定义了两个字段，一个是`String`类型的字段，命名为`name`, 一个是`int`类型的字段，命名为`age`。因此，可以通过`class`，把一组数据汇集到一个对象上，实现对数据的封装。

`public`是用来修饰字段的，它表示这个字段可以被外部访问。

我们再来看另一个例子：

    class Book {
        public String name;
        public String author;
        public String isbn;
        public double price;
    }

请指出以上的`Book`类的字段有哪些？

**创建实例**

定义了class, 只是定义了对象模板，而要根据对象模板创建出真正的对象实例，必须使用new运算符。

new运算符可以创建一个实例，之后，我们需要定义一个引用类型的变量来指向这个实例：

    Person ming = new Person();

上述代码创建了一个Person类型的实例，并通过`ming`指向它。

注意上述赋值运算符的两侧，一个是定义`Person`类型的变量`ming`，一个是创建`Person`类型的实例。

有了指向这个实例的变量，我们就可以通过这个变量来操作实例。访问实例变量可以用`变量.字段`，例如：

    ming.name = "xiao ming";
    ming.age = 12;
    System.out.println(ming.name);

    Person hong = new Person();
    hong.name = "xiao hong"
    hong.age = 15;

上述两个变量分别指向两个不同的实例，

![alt text](image.png)

上面两个`instance`都有`class`定义的`name`和`age`字段，且各自都有一份独立的数据，互不干扰。

**注意**：一个Java源文件可以包含多个类的定义，但只是定义一个public类，且public类名必须与文件名一致。如果要定义多个public类，必须拆到多个Java源文件中。

**练习**

请定义一个City类，该class具有如下字段：

- name:名称， String类型
- latitude:纬度，double类型
- longitude:经度，double类型

实例化几个city并赋值，然后打印。

    public class Main{
        public static void main(String[] args) {
            City bj = new City();
            bj.name = "Beijing";
            bj.latitude = 39.903;
            bj.longitude = 116.401;
            System.out.println(bj.name);
            System.out.println("location: " + bj.latitude + ", " + bj.longitide);
        }
    }

    class City {
        public String name;
        public double latitude;
        public double longitude;
    }

**小结**

- 在OOP中，`class`和`instance`是**模板**与**实例**的关系；
- 定义`class`就是定义了一种数据类型，对应的`instance`就是这种数据类型的实例；
- `class`定义的`field`，在每个`instance`都会拥有各自的`field`，且互不干扰。
- 通过`new`操作符创建新的`instance`，然后用变量指向它，即可以通过变量来引用这个`instance`;
- 访问实例字段的方法是`变量名.字段名`;
- 指向`instance`的变量都是引用变量。

### 方法

一个`class`可以包含多个`field`，例如，我们给`Person`类就定义了两个`field`：

    class Person {
        public String name;
        public int age;
    }

但是，直接把`field`用`public`暴露给外部可能会破坏封装性。比如，

    Person ming = new Person();
    ming.name = "xiao ming";
    ming.age = -99;

显然，直接操作`field`，容易造成逻辑混乱。为了避免外部代码直接去访问`field`，我们可以用`private`修饰`field`，拒绝外部访问：

    class Person{
        private String name;
        private int age;
    }

好的，现在我们来试试`private`修饰的`field`有什么效果：

    public class Main {
        public static void main(String[] args){
            Person ming = new Person();
            ming.name = "xiao ming";
            ming.age = 12;
        }
    }

    class Person {
        private String name;
        private int age;
    }

是不是编译报错？把访问`field`的赋值语句去了就可以正常编译了。

当我们将`field`从`public`改成`private`，外部代码不能直接访问这些field，跟我们定义这些`field`有什么用？怎么样才能给它赋值呢？怎么样才能读取它的值？

所以我们需要使用方法（`method`）来让外部代码可以间接修改`field`:

    public class Main {
        public static void main(String[] args) {
            Person ming = new Person();
            ming.setName("xiao ming");
            ming.setAge(12);
            System.out.println(ming.getName() + ", " + ming.getAge());
        }
    }

    class Person {
        private String name;
        private int age;

        public String getName() {
            return this.name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return this.age;
        }

        public void setAge(int age) {
            if (age < 0 || age > 100) {
                throw new IllegalArgumentException("invalid age value");
            }
            this.age = age;
        }
    }

虽然外部代码不能直接修改`private`字段，但是，外部代码可以调用方法`setName()`和`setAge()`来间接修改`private`字段。在方法内部，我们就有机会检查参数对不对。比如，`setAge()`就会检查传入的参数，参数超出了范围，直接报错。这样，外部代码就没有任何机会会把`age`设置成不合理的数值。

对`setName()`方法同样可以做检查，例如，不允许传入`null`和空字符串：

    public void setName(String name) {
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("invalid name");
        }
        this.name = name.strip();
    }

同样，外部代码不能直接读取`private`字段，但可以通过`getName()`和`getAge()`间接获取`private`字段的数值。

所以，一个类通过定义方法，就可以给外部代码暴露一些接口的操作，同时，内部自己保证逻辑一致性。

调用方法的语法是`实例方法.方法名(参数);`。一个方法调用就是一个语句，所以不要忘了在末尾加上`;`。例如：`ming.setName("xiao ming");` 。

**定义方法**

从上面的代码中，我们可以看出，定义方法的语法是：

    修饰符 方法返回类型 方法名（方法参数列表） {
        若干方法语句;
        return 方法返回值;
    }

方法返回值通过`return`语句实现，如果没有返回值，返回类型设置为`void`，可以省略`return`。

**private方法**

有了`public`方法，自然就有`private`方法，和`private`字段一样，`private`方法不允许外部调用，那我们定义`private`方法有什么用呢?

定义`private`方法的理由是内部方法是可以调用`private`方法的，例如：

    public class Main {
        public static void main(String[] args) {
            Person ming = new Person();
            ming.setBirth(2008);
            System.out.println(ming.getAge());
        }
    }

    class Person {
        private String name;
        private int birth;

        public void setBirth(int birth) {
            this.birth = birth;
        }

        public int getAge() {
            return calcAge(2019);
        }

        private int calcAge(int currentYear) {
            return currentYear - this.birth;
        }
    }

观察上述代码，`calcAge()`是一个`private`方法，外部代码无法调用，但是，内部方法`getAge()`可以调用它。

此外，我们还注意到，这个`Person`类只定义了`birth`字段，没有定义`age`字段，获取`age`时，通过方法`getAge()`返回的是一个实时计算的数值，而不是存储在某个字段的值。这说明方法可以封装一个类的对外接口，调用方法不需要知道也不关心`Person`实例在内部到底有没有`age`字段。

**this变量**

在方法内部，可以使用一个隐含的变量`this`，它始终指向当前实例。因此，通过`this.field`就可以访问当前实例的字段。

如果没有命名冲突，可以省略`this`。例如：

    class Person {
        private String name;

        public String getName() {
            return name;
        }
    }

但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上`this`：

    class Person {
        private String name;

        public void setName(String name) {
            this.name = name;
        }
    }

**方法参数**

方法可以包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义————传递。例如：

    class Person {
        ...
        public void setNameAndAge(String name, int age) {
            ...
        }
    }

调用这个`setNameAndAge()`方法时，必须有两个参数，且第一个参数必须为`String`, 第二个参数必须为`int`:

    Person ming = new Person();
    ming.setNameAndAge("xiaoming");     //编译错误，参数个数不对
    ming.setNameAndAge(12, "xiaoming"); //编译错误，参数类型不对

**可变参数**

可变参数用`类型...`定义，可变参数相当于数组类型：

class Group {
    private String[] names;

    public void setNames(String... names) {
        this.names = names;
    }
}

上面的`setNames()`就定义了一个可变参数。调用时，可以这么写：

    Group g = new Group();
    g.setNames("xiao ming", "xiao hong", "xiao jun");
    g.setNames("xiao ming", "xiao hong");
    g.setNames("xiao ming");
    g.setNames();

完全可以把可变参数改写为`String[]`类型：

class Group {
    private String[] namess;

    public void setNames(String[] names) {
        this.names = names;
    }
}

但是，调用方需要自己先构造`String[]`，比较麻烦。例如：

Group g = new Group();
g.setNames(new String[] {"Xiao Ming", "Xiao Hong", "Xiao Jun"}); 

另一个问题是，调用方可以传入`null`：

Group g = new Group();
g.setNames(null);

而可变参数可以保证无法传入`null`，因为传入0个参数时，接收到的实际值是一个空数组而不是`null`。

**参数绑定**

调用方把参数传递给实例方法时，调用时传递的值会按照参数位置一一绑定。

那什么时参数绑定呢？

我们先来观察一个基本类型参数的传递：

public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        int n = 15;
        p.setAge(n);
        System.out.println(p.getAge());
        n = 20;
        System.out.println(p.getAge());
    }
}

class Person {
    private int age;

    public int getAge() {
        return this.age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

运行代码，从结果可知，修改外部的局部变量`n`，不影响实例`p`的`age`字段，原因是`setAge()`方法获得的参数，复制了`n`的数值，因此，`p.age`和局部变量`n`互不影响。

结论：基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。

我们再看一个传递引用参数的例子：

public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        String[] fullname = new String[] { "Homer", "Simpson" }
        p.setName(fullname);
        System.out.println(p.getName());
        fullname[0] = "Bart";
        System.out.println(p.getName());
    }
}

class Person {
    private String[] name;

    public String getName() {
        return this.name[0] + " " + this.name[1];
    }

    public void setName(String[] name) {
        this.name = name;
    }
}

注意到`setName()`的参数现在是一个数组。一开始，把`fullname`数组传进去，然后，修改`fullname`数组的内容，结果发现，实例`p`的字段`p.name`也被修改了！

**结论**

引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双向任意一方对这个对象的修改，都会影响对方(因为指向同一个对象嘛)。

有了上面的结论，我们再看一个例子：

public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        String bob = "Bob"
        p.setName(bob);
        System.out.println(p.getName());
        bob = "A    "
    } 
}

class Person {
    private String name;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

**小结：**

- 方法可以让外部代码安全地访问实例字段；
- 方法是一组执行语句，并且可以执行任意逻辑；
- 方法内部遇到return时返回，void表示不返回任何值（注意和返回null不同）；
- 外部代码通过public方法操作实例，内部代码可以调用private方法；



### 构造方法

创建实例的时候，我们经常需要同时初始化这个实例的字段，例如：

Person ming = new Person();
ming.setName("xiao ming");
ming.setAge(12);

初始化对象实例需要三行代码，而且，如果忘了调用`setName()`或者`setAge()`,这个实例内部的状态就是不正确的。

能否在创建对象实例时就把内部字段全部初始化为合适的值？

完全可以。

这是，我们就需要构造方法。

创建实例的时候，实际上是通过构造方法来初始化实例的。我们先来定义一个构造方法，能在创建`Person`实例的时候，一次性传入`name`和`age`，完成初始化：

public class Main {
    public static void main(String[] args) {
        Person p = new Person("xiao ming", 15)
        System.out.println(p.getName());
        System.out.println(p.getAge());
    }
}

class Person {
    private String name;
    private int age;

    public Person(Sting name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return this.name;
    }

    public int getAge() {
        return this.age;
    }
}

由于构造方法是如此特殊，所以构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值(也没有`void`),调用构造方法，必须用`new`操作符。

**默认构造方法**

是不是任何的`class`都有构造方法？是的。

那前面我们并没有为`Person`类编写构造方法，为什么可以调用`new Person()`?

原因是如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句，类似这样：

class Person {
    public Person() {
    }
}

要特别注意的是，如果我们自定义了一个构造方法，那么，编译器就不再自动化创建默认构造方法：

public class Main {
    public static void main(String[] args) {
        Person p = new Person();
    }
}

class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return this.name;
    }

    public int getAge() {
        return this.age;
    }
}

如果既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来：

public class Main {
    public static void main(String[] args) {
        Person p1 = new Person("xiao ming", 15);
        Person p2 = new Person();
    }
}

class Person {
    private String name;
    private int age;

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return this.name;
    }

    public int getAge() {
        return this.age;
    }
}

没有在构造方法中初始化字段时，引用类型的字段默认是`null`，数值类型的字段用默认值，`int`类型默认值是`0`，布尔类型的默认值是`false`：

class Person {
    private String name;
    private int age;

    public Person() {
    }
}

也可以对字段直接进行初始化：

class Person {
    private String name = "Unameed";
    private int age = 10;

    public Person(String name, int age) {
        this.name = name;
        this.name = age;
    }
}

当我们创建对象的时候，`new Person("xiao ming", 12)`得到的对象实例，字段的初始值是啥？

在Java中，创建对象实例的时候，按照如下顺序进行初始化：

1. 先初始化字段，例如，`int age = 10;` 表示字段初始化为`10`,`double salary;`表示字段默认初始化为`0`，`String s;`表示引用类型字段默认初始化为`null;`
2. 执行构造方法的代码进行初始化。

因此，构造方法的代码由于后运行，所以,`new Person("xiao ming", 12)`的字段值最终有构造方法的代码确定。

**多个构造方法**

可以定义多个构造方法，在通过`new`操作符调用的时候，编译器通过构造方法的参数数量，位置和类型自动区分：

class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Person(String name) {
        this.name = name;
        this.age = 12;
    }

    public Person() {
    }
}

如果调用`new Person("xiao ming", 20);`，会自动匹配到构造方法`public Person(String, int)`。

如果调用`new Person("xiao ming");`，会自动匹配到构造方法`public Person()`。

如果调用`new Person();`，会自动匹配到构造方法`public Person()`。

一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是`this(...)`:

class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Person(String name) {
        this(name, 18);
    }

    public Person() {
        this("Unnamed");
    }
}

**小结**

- 实例在创建时通过`new`操作符会调用其对应的构造方法，构造方法用于初始化实例；
- 没有定义构造方法时，编译器会自动创建一个默认的无参数构造方法；
- 可以定义多个构造方法，编译器根据参数自动判断；
- 可以在一个构造方法内部调用另一个构造方法，便于代码复用。












### 


## Java核心类

